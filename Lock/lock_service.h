//
//  lock_service.h
//  Prob_verify
//
//  Created by Shou-pon Lin on 8/27/12.
//  Copyright (c) 2012 Shou-pon Lin. All rights reserved.
//

#ifndef LOCK_SERVICE_H
#define LOCK_SERVICE_H

#include "../statemachine.h"

class Lock_service: public StateMachine
{
    Lock_service( Lookup* msg, Lookup* mac ): StateMachine(msg, mac) { }
    
    // Simulate message reception
    // inMsg: the message transmitted to this StateMachine
    // outMsgs: the output messages generated by the matching transition
    // startIdx: the starting idx from which the search for matching transition starts
    // This function should return the starting index for the next search. A negative
    // return value is used to indicate failure to find a matching transition
    
    // Note: when creating tasks, the tasks should be cloned instead of copy the pointer.
    // There may be same tasks in different childs created by multiple low probability
    // transition. The task (tuple) will be deleted once it is evaluated in evaluate().
    // Cloning tasks avoids dereference of deallocated objects when the same tasks are
    // being evaluated in multiple childs
    virtual int transit(MessageTuple* inMsg, vector<MessageTuple*>& outMsgs,
                        bool& high_prob, int startIdx = 0) = 0;
    // Returns the identifier of current state
    virtual int nullInputTrans(vector<MessageTuple*>& outMsgs,
                               bool& high_prob, int startIdx = 0) = 0;
    // Restore the state of a StateMachine back to a previous point which can be completely specified
    // by s StateSnapshot
    virtual void restore(const StateSnapshot* snapshot) = 0;
    // Store current snapshot. This function should allocate a new StateSnapshot* object. The object would be
    // deallocate after the process of probabilistic verification is complete, when all the StateSnapshot* in the
    // _uniqueTable is released.
    virtual StateSnapshot* curState() = 0 ;
    // Reset the machine to initial state
    virtual void reset() = 0;
    
};


class ServiceMessage
{
public:
    MessageTuple(int src, int dest, int srcMsg, int destMsg, int subject)
    :_src(src), _dest(dest), _srcMsg(srcMsg), _destMsg(destMsg), _subject(subject) {};
    
    virtual ~MessageTuple() {}
    
    int srcID() {return _src;}
    int destId() {return _dest;}
    int srcMsgId() {return _srcMsg;}
    int destMsgId() {return _destMsg;}
    int subjectId() {return _subject;}
    
    virtual size_t numParams() = 0;
    virtual int getParam(size_t arg) = 0 ;
    
    string toString()
    {
        stringstream ss;
        ss << "subject=" << _subject << ":" ;
        ss << "(" << _src << "?" << _srcMsg << "," << _dest << "!" << _destMsg << ")" ;
        return ss.str() ;
    }
    
    virtual MessageTuple* clone() = 0 ;
protected:
    int _src;
    int _dest;
    int _srcMsg;
    int _destMsg;
    int _subject;
};

class StateSnapshot
{
    friend class StateMachine;
public:
    virtual ~StateSnapshot() {} ;
    virtual int curStateId() const = 0 ;
    // Returns the name of current state as specified in the input file
    virtual string toString() = 0 ;
    // Cast the Snapshot into a integer. Used in HashTable
    virtual int toInt() = 0;
    virtual StateSnapshot* clone() = 0 ;
};


#endif
