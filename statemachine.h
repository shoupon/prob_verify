#ifndef STATEMACHINE_H
#define STATEMACHINE_H

#include <vector>
#include <string>
#include <exception>
#include <stdexcept>
#include <memory>
#include <sstream>
using namespace std;

#include "define.h"
#include "lookup.h"

class MessageTuple
{
public:
    MessageTuple(int src, int dest, int srcMsg, int destMsg, int subject)
    :_src(src), _dest(dest), _srcMsg(srcMsg), _destMsg(destMsg), _subject(subject) {}
    
    MessageTuple( const MessageTuple& tuple ):_src(tuple._src), _dest(tuple._dest),
    _srcMsg(tuple._srcMsg), _destMsg(tuple._destMsg), _subject(tuple._subject) {}
    
    virtual ~MessageTuple() {}
    
    int srcID() {return _src;}
    int destId() {return _dest;}
    int srcMsgId() {return _srcMsg;}
    int destMsgId() {return _destMsg;}
    int subjectId() {return _subject;}

    virtual size_t numParams() { return 0 ; }
    virtual int getParam(size_t arg) { return 0 ; }
    
    virtual string toString()
    {
        stringstream ss;
        ss << "subject=" << _subject << ":" ;
        ss << "(" << _src << "?" << _srcMsg << "," << _dest << "!" << _destMsg << ")" ;
        return ss.str() ;
    }
    
    virtual MessageTuple* clone() const {return new MessageTuple(*this); }
protected:
    int _src;
    int _dest;
    int _srcMsg;
    int _destMsg;
    int _subject;
};

class StateMachine;

// Used for restore the state of a state machine back to a certain point. Should contain
// the state in which the machine was, the internal variables at that point
class StateSnapshot
{
    friend class StateMachine;
public:
    StateSnapshot(): _ss_state(0) {}
    StateSnapshot(int s):_ss_state(s) {}
    virtual ~StateSnapshot() {}
    virtual int curStateId() const { return _ss_state; }
    // Returns the name of current state as specified in the input file. Used to identify
    // states in the set STATET, STATETABLE, RS
    virtual string toString();
    // Cast the Snapshot into a integer. Used in HashTable
    virtual int toInt() {return _ss_state;}
    virtual StateSnapshot* clone() const { return new StateSnapshot(_ss_state); }
    virtual bool match(StateSnapshot* other) { return toString() == other->toString(); }
    
protected:
    int _ss_state;
};

class StateMachine
{
public:
    // When the class is constructed, a lookup function should be provided to the
    // StateMachine, so the StateMachine can convert a string of an input or an output
    // label into id (integer). A pointer to Parser should be provided to the StateMachine.
    // The Parser class contains the necessary look up function that StateMachine needs
    StateMachine( Lookup* msg, Lookup* mac ) {}
    virtual ~StateMachine() {}

    // Simulate message reception
    // inMsg: the message transmitted to this StateMachine
    // outMsgs: the output messages generated by the matching transition
    // startIdx: the starting idx from which the search for matching transition starts
    // This function should return the starting index for the next search. A negative
    // return value is used to indicate failure to find a matching transition
    
    // Note: when creating tasks, the tasks should be cloned instead of copy the pointer.
    // There may be same tasks in different childs created by multiple low probability
    // transition. The task (tuple) will be deleted once it is evaluated in evaluate().
    // Cloning tasks avoids dereference of deallocated objects when the same tasks are
    // being evaluated in multiple childs
    virtual int transit(MessageTuple* inMsg, vector<MessageTuple*>& outMsgs,
                           bool& high_prob, int startIdx = 0) = 0;
    // Returns the identifier of current state
    virtual int nullInputTrans(vector<MessageTuple*>& outMsgs,
                                  bool& high_prob, int startIdx = 0) = 0;
    // Restore the state of a StateMachine back to a previous point which can be
    // completely specified by a StateSnapshot
    virtual void restore(const StateSnapshot* snapshot) { _state = snapshot->curStateId(); }
    // Store current snapshot. This function should allocate a new StateSnapshot* object.
    // The object would be deallocate after the process of probabilistic verification is
    // complete, when all the StateSnapshot* in the _uniqueTable is released.
    virtual StateSnapshot* curState() { return new StateSnapshot(_state); }
    // Reset the machine to initial state
    virtual void reset() { _state = 0 ; }
    
    int macId() const { return _machineId; }
    void setId(int num) { _machineId = num ; }
    
    static void setLookup(Lookup* msg, Lookup* mac){ _msgLookup = msg, _macLookup = mac;}
    
protected:
    static Lookup* _msgLookup;
    static Lookup* _macLookup;
    int _state;
    
    static int messageToInt(string msg) ;
    static int machineToInt(string macName) ;
    static string IntToMessage(int num) { return _msgLookup->toString(num); }
    static string IntToMachine(int num) { return _macLookup->toString(num); }
    
private:
    int _machineId;
};

#endif
